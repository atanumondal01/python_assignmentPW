# -*- coding: utf-8 -*-
"""assignment-icon OOPS Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-BfDwLBTXmmRJIjwb9NqwkzfpWpXVwTW
"""



#Q1 Explain Class and Object with respect to Object-Oriented Programming. Give a suitable example.

"""In object-oriented programming (OOP), a class is a blueprint or a template for creating objects. It defines the
structure and behavior that an object will have. A class encapsulates data (attributes) and functions (methods) that
 operate on that data. It serves as a blueprint for creating multiple instances of objects with similar characteristics.

An object, on the other hand, is an instance of a class. It is a real-world entity that possesses state
 (values of attributes) and behavior (functions or methods). Objects are created based on the defined structure and
 behavior specified by the class. Each object can have its own unique values for the attributes defined in the class."""

class Car:
    def __init__(self, brand, model, color):
        self.brand = brand
        self.model = model
        self.color = color

    def start(self):
        print("The car has started.")

    def accelerate(self):
        print("The car is accelerating.")

    def stop(self):
        print("The car has stopped.")

car1 = Car("Toyota", "Camry", "Red")
car2 = Car("Ford", "Mustang", "Blue")

car1.start()     # Output: The car has started.
car2.accelerate()     # Output: The car is accelerating.
car1.stop()     # Output: The car has stopped.



#Q2 Q2. Name the four pillars of OOPs.

"""The four pillars of object-oriented programming (OOP) are:

1. Encapsulation: Bundling data and methods together within a class, promoting data hiding and abstraction.

2. Inheritance: Creating new classes based on existing classes, allowing for code reuse and modification.

3. Polymorphism: Objects of different classes can be treated as objects of a common superclass, enabling different
behaviors.

4. Abstraction: Representing essential features of real-world entities in a simplified manner, providing a higher-level
view and hiding complexities.

These four pillars form the fundamental principles of OOP, facilitating code organization, reusability,
and maintainability in software development."""



#Q3  Explain why the __init__() function is used. Give a suitable example.

"""The __init__ function, also known as the constructor, is used in object-oriented programming to initialize the
attributes of an object when it is created from a class. It is automatically called when an object is instantiated.

The primary purpose of the `__init__()` function is to set the initial state or values of the object's attributes. It
allows us to specify what data should be associated with an object and initialize it to a desired state. By defining this
function within a class, we can ensure that the necessary setup steps are performed whenever a new object of that class is created.

Here's an example
"""

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def introduce(self):
        print(f"My name is {self.name} and I am {self.age} years old.")

person1 = Person("Alice", 25)

person1.introduce()



#Q4 Why self is used in OOPs?

"""In object-oriented programming (OOP), the self keyword is used:

1. To refer to the instance of a class within its methods, allowing access to its attributes and methods.

2. It differentiates between instance variables (object-specific) and class variables (shared among all instances).

3.It ensures that the correct instance is being referenced, especially in scenarios involving multiple objects of the
same class."""



#Q5.What is inheritance? Give an example for each type of inheritance.

"""Inheritance is a fundamental concept in object-oriented programming (OOP) that allows the creation of new
 classes (derived or child classes) based on existing classes (base or parent classes). It enables the derived classes
  to inherit the properties and behavior of the parent class, promoting code reuse and reducing redundancy.

There are several types of inheritance:

1. Single Inheritance: In single inheritance, a derived class inherits properties and methods from a single base class.
 It forms a simple hierarchy where each derived class has only one immediate base class."""


class Animal:
    def eat(self):
        print("Eating...")

class Dog(Animal):
    def bark(self):
        print("Barking...")

dog = Dog()
dog.eat()   # Output: Eating...
dog.bark()  # Output: Barking...


"""2. Multiple Inheritance: Multiple inheritance allows a derived class to inherit properties and methods from multiple
base classes. It enables the derived class to combine the features of different classes."""

class Fish:
    def swim(self):
        print("Swimming...")

class Bird:
    def fly(self):
        print("Flying...")

class FlyingFish(Fish, Bird):
    pass

flying_fish = FlyingFish()
flying_fish.swim()
flying_fish.fly()


"""3. Multilevel Inheritance: In multilevel inheritance, a derived class inherits properties and methods from a base class,
and that derived class becomes the base class for another class. It forms a hierarchical chain of classes."""



class Animal:
    def eat(self):
        print("Eating...")

class Mammal(Animal):
    def sleep(self):
        print("Sleeping...")

class Dog(Mammal):
    def bark(self):
        print("Barking...")

dog = Dog()
dog.eat()
dog.sleep()
dog.bark()


"""4. Hierarchical Inheritance: In hierarchical inheritance, multiple derived classes inherit properties and methods
from a single base class. It allows the base class to serve as a common superclass for multiple derived classes."""


class Shape:
    def draw(self):
        print("Drawing...")

class Circle(Shape):
    def calculate_area(self):
        print("Calculating area of circle...")

class Rectangle(Shape):
    def calculate_area(self):
        print("Calculating area of rectangle...")

circle = Circle()
circle.draw()
circle.calculate_area()

rectangle = Rectangle()
rectangle.draw()
rectangle.calculate_area()





